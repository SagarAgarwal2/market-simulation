<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Twin Market Engine ‚Äì ML-Powered FMCG Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/dist/ml-matrix.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 40px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .ml-badge {
            position: absolute;
            top: 20px;
            right: 40px;
            background: #ffc107;
            color: #333;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            box-shadow: 0 4px 10px rgba(255, 193, 7, 0.4);
        }

        .main-content {
            display: flex;
            min-height: calc(100vh - 200px);
        }

        .sidebar {
            width: 340px;
            background: #f8f9fa;
            padding: 30px;
            border-right: 2px solid #e0e0e0;
            overflow-y: auto;
        }

        .sidebar h2 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.4em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 30px;
        }

        .input-group label {
            display: block;
            font-weight: 600;
            color: #444;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .input-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            -webkit-appearance: none;
        }

        .input-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .input-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .value-display {
            text-align: right;
            color: #667eea;
            font-weight: bold;
            font-size: 1.1em;
            margin-top: 5px;
        }

        .toggle-group {
            display: flex;
            gap: 10px;
        }

        .toggle-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .toggle-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            font-weight: 600;
        }

        .run-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .run-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .run-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .ml-status {
            background: #e3f2fd;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.85em;
            border-left: 4px solid #2196F3;
        }

        .dashboard {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .metric-card.ml-powered {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: #333;
        }

        .metric-label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
        }

        .ml-tag {
            font-size: 0.7em;
            background: rgba(255,255,255,0.3);
            padding: 3px 8px;
            border-radius: 10px;
            display: inline-block;
            margin-top: 5px;
        }

        .chart-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .chart-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .chart-container {
            position: relative;
            height: 300px;
        }

        .insights-section {
            background: #fff3cd;
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #ffc107;
            margin-bottom: 25px;
        }

        .insights-section.ml-insights {
            background: #d1f2eb;
            border-left: 5px solid #43e97b;
        }

        .insights-section h3 {
            color: #856404;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .insights-section.ml-insights h3 {
            color: #0a5d4a;
        }

        .insight-item {
            margin-bottom: 12px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border-left: 3px solid #ffc107;
        }

        .ml-insights .insight-item {
            border-left: 3px solid #43e97b;
        }

        .insight-label {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .insight-value {
            color: #666;
            font-size: 0.9em;
        }

        .risk-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .risk-low {
            background: #d4edda;
            color: #155724;
        }

        .risk-medium {
            background: #fff3cd;
            color: #856404;
        }

        .risk-high {
            background: #f8d7da;
            color: #721c24;
        }

        .placeholder {
            text-align: center;
            padding: 60px;
            color: #999;
            font-size: 1.2em;
        }

        .hidden {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        .comparison-table tr:hover {
            background: #f5f5f5;
        }

        @media (max-width: 1024px) {
            .main-content {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 2px solid #e0e0e0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="ml-badge">ü§ñ ML-Powered</div>
            <h1>‚ö° Digital Twin Market Engine</h1>
            <p>ML-Enhanced FMCG Launch Simulator ‚Äì Women's Protein Drink | India Market</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="ml-status" id="mlStatus">
                    üîÑ Initializing ML models...
                </div>

                <h2>Product Configuration</h2>

                <div class="input-group">
                    <label>Price (INR)</label>
                    <input type="range" id="priceSlider" min="299" max="599" value="449" step="10">
                    <div class="value-display">‚Çπ<span id="priceValue">449</span></div>
                </div>

                <div class="input-group">
                    <label>Sugar-Free Option</label>
                    <div class="toggle-group">
                        <button class="toggle-btn" id="sugarNoBtn">No</button>
                        <button class="toggle-btn active" id="sugarYesBtn">Yes</button>
                    </div>
                </div>

                <div class="input-group">
                    <label>Packaging Type</label>
                    <select id="packagingSelect">
                        <option value="basic">Basic</option>
                        <option value="premium">Premium</option>
                    </select>
                </div>

                <div class="input-group">
                    <label>Influencer Marketing Campaign</label>
                    <div class="toggle-group">
                        <button class="toggle-btn" id="influencerNoBtn">No</button>
                        <button class="toggle-btn active" id="influencerYesBtn">Yes</button>
                    </div>
                </div>

                <button class="run-btn" id="runSimulation">üöÄ Run ML Simulation</button>
            </div>

            <div class="dashboard">
                <div id="loading" class="loading hidden">
                    <div class="spinner"></div>
                    <div>Training ML models and running predictions...</div>
                </div>

                <div id="placeholder" class="placeholder">
                    üëÜ Configure product parameters and click "Run ML Simulation" to see AI-powered insights
                </div>

                <div id="results" class="hidden">
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-label">Rule-Based Probability</div>
                            <div class="metric-value"><span id="ruleProb">0</span>%</div>
                        </div>
                        <div class="metric-card ml-powered">
                            <div class="metric-label">ML Predicted Probability</div>
                            <div class="metric-value"><span id="mlProb">0</span>%</div>
                            <div class="ml-tag">Neural Network</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">Estimated Revenue</div>
                            <div class="metric-value">‚Çπ<span id="revenue">0</span></div>
                        </div>
                        <div class="metric-card ml-powered">
                            <div class="metric-label">Customer Lifetime Value</div>
                            <div class="metric-value">‚Çπ<span id="clv">0</span></div>
                            <div class="ml-tag">Predictive Model</div>
                        </div>
                        <div class="metric-card ml-powered">
                            <div class="metric-label">Market Size (TAM)</div>
                            <div class="metric-value"><span id="tam">0</span></div>
                            <div class="ml-tag">Regression</div>
                        </div>
                    </div>

                    <div class="insights-section ml-insights">
                        <h3>ü§ñ ML-Powered Optimal Pricing</h3>
                        <div class="insight-item">
                            <div class="insight-label">Recommended Optimal Price</div>
                            <div class="insight-value" id="optimalPrice">-</div>
                        </div>
                        <div class="insight-item">
                            <div class="insight-label">Expected Revenue at Optimal Price</div>
                            <div class="insight-value" id="optimalRevenue">-</div>
                        </div>
                        <div class="insight-item">
                            <div class="insight-label">ML Confidence Score</div>
                            <div class="insight-value" id="confidence">-</div>
                        </div>
                    </div>

                    <div class="chart-section">
                        <h3>üìä ML-Discovered Customer Clusters</h3>
                        <div class="chart-container">
                            <canvas id="clusterChart"></canvas>
                        </div>
                        <div style="margin-top: 15px; font-size: 0.9em; color: #666;">
                            K-means clustering identified <strong id="clusterCount">0</strong> natural customer segments
                        </div>
                    </div>

                    <div class="chart-section">
                        <h3>üìà Purchase Probability: Rule-Based vs ML Model</h3>
                        <div class="chart-container">
                            <canvas id="comparisonChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-section">
                        <h3>üí∞ Revenue Optimization Curve</h3>
                        <div class="chart-container">
                            <canvas id="revenueChart"></canvas>
                        </div>
                    </div>

                    <div class="insights-section ml-insights">
                        <h3>üéØ Churn & Retention Prediction</h3>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Segment</th>
                                    <th>Repurchase Rate</th>
                                    <th>Churn Risk</th>
                                    <th>CLV</th>
                                    <th>Priority</th>
                                </tr>
                            </thead>
                            <tbody id="churnTable">
                            </tbody>
                        </table>
                    </div>

                    <div class="insights-section">
                        <h3>üí° Traditional Business Insights</h3>
                        <div class="insight-item">
                            <div class="insight-label">Most Responsive Segment</div>
                            <div class="insight-value" id="responsiveSegment">-</div>
                        </div>
                        <div class="insight-item">
                            <div class="insight-label">Launch Risk Level</div>
                            <div class="insight-value">
                                <span class="risk-badge" id="riskBadge">-</span>
                            </div>
                        </div>
                        <div class="insight-item">
                            <div class="insight-label">Strategic Recommendation</div>
                            <div class="insight-value" id="recommendation">-</div>
                        </div>
                    </div>

                    <div class="insights-section ml-insights">
                        <h3>üåç Regional Market Size Estimation</h3>
                        <div id="regionalData"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // MACHINE LEARNING MODULE
        // ========================================

        class MLEngine {
            constructor() {
                this.purchaseModel = null;
                this.trainingData = null;
                this.isReady = false;
            }

            // Generate synthetic training data based on real FMCG patterns
            generateTrainingData(samples = 2000) {
                const data = [];
                
                for (let i = 0; i < samples; i++) {
                    const price = 299 + Math.random() * 300;
                    const healthConsciousness = 1 + Math.random() * 9;
                    const priceSensitivity = 1 + Math.random() * 9;
                    const brandLoyalty = 1 + Math.random() * 9;
                    const age = 18 + Math.random() * 47;
                    const sugarFree = Math.random() > 0.5 ? 1 : 0;
                    const premium = Math.random() > 0.5 ? 1 : 0;
                    const influencer = Math.random() > 0.5 ? 1 : 0;
                    const urban = Math.random() > 0.4 ? 1 : 0;
                    const highIncome = Math.random() > 0.6 ? 1 : 0;

                    // Complex non-linear purchase probability
                    let purchaseProb = 0.3;

                    // Price effect with non-linearity
                    purchaseProb += (1 - price/600) * (10 - priceSensitivity) * 0.04;

                    // Health consciousness interactions
                    if (sugarFree === 1) {
                        purchaseProb += healthConsciousness * 0.06;
                        // Interaction: health-conscious + premium + sugar-free
                        if (premium === 1) {
                            purchaseProb += healthConsciousness * 0.02;
                        }
                    } else {
                        purchaseProb -= healthConsciousness * 0.04;
                    }

                    // Premium packaging effects
                    if (premium === 1) {
                        purchaseProb += brandLoyalty * 0.03;
                        if (highIncome === 1) {
                            purchaseProb += 0.1;
                        }
                    }

                    // Influencer marketing (especially for young urban)
                    if (influencer === 1) {
                        purchaseProb += (10 - brandLoyalty) * 0.025;
                        if (urban === 1 && age < 35) {
                            purchaseProb += 0.12;
                        }
                    }

                    // Hidden patterns (ML will discover these)
                    // Pattern 1: Tier-2 mothers need both sugar-free AND influencer
                    if (urban === 0 && age > 30 && age < 45 && sugarFree === 1 && influencer === 1) {
                        purchaseProb += 0.15;
                    }

                    // Pattern 2: High price + premium + influencer works for young urban high-income
                    if (price > 500 && premium === 1 && influencer === 1 && urban === 1 && age < 35 && highIncome === 1) {
                        purchaseProb += 0.18;
                    }

                    // Pattern 3: Senior citizens need low price regardless of features
                    if (age > 55 && price > 450) {
                        purchaseProb -= 0.25;
                    }

                    // Add some noise
                    purchaseProb += (Math.random() - 0.5) * 0.1;

                    // Clamp to 0-1
                    purchaseProb = Math.max(0, Math.min(1, purchaseProb));

                    data.push({
                        inputs: [price/600, healthConsciousness/10, priceSensitivity/10, 
                                brandLoyalty/10, age/70, sugarFree, premium, influencer, 
                                urban, highIncome],
                        output: purchaseProb
                    });
                }

                this.trainingData = data;
                return data;
            }

            // Train neural network for purchase prediction
            async trainPurchaseModel() {
                console.log('Training purchase prediction model...');
                
                this.generateTrainingData(2000);

                // Create TensorFlow.js model
                this.purchaseModel = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [10], units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.1 }),
                        tf.layers.dense({ units: 8, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'sigmoid' })
                    ]
                });

                this.purchaseModel.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mse']
                });

                // Prepare training data
                const inputs = tf.tensor2d(this.trainingData.map(d => d.inputs));
                const outputs = tf.tensor2d(this.trainingData.map(d => [d.output]));

                // Train
                await this.purchaseModel.fit(inputs, outputs, {
                    epochs: 50,
                    batchSize: 32,
                    validationSplit: 0.2,
                    verbose: 0
                });

                inputs.dispose();
                outputs.dispose();

                console.log('Purchase model trained!');
                this.isReady = true;
                return true;
            }

            // Predict purchase probability using ML
            predictPurchase(persona, config) {
                if (!this.isReady) return null;

                const input = tf.tensor2d([[
                    config.price / 600,
                    persona.healthConsciousness / 10,
                    persona.priceSensitivity / 10,
                    persona.brandLoyalty / 10,
                    persona.age / 70,
                    config.sugarFree ? 1 : 0,
                    config.packaging === 'premium' ? 1 : 0,
                    config.influencer ? 1 : 0,
                    persona.cityType === 'Urban' ? 1 : 0,
                    persona.incomeLevel === 'High' ? 1 : 0
                ]]);

                const prediction = this.purchaseModel.predict(input);
                const value = prediction.dataSync()[0] * 100;

                input.dispose();
                prediction.dispose();

                return value;
            }

            // K-means clustering for persona discovery
            performClustering(personas, k = 6) {
                // Prepare data for clustering
                const data = personas.map(p => [
                    p.healthConsciousness / 10,
                    p.priceSensitivity / 10,
                    p.brandLoyalty / 10,
                    p.age / 70
                ]);

                // Simple k-means implementation
                const clusters = this.kMeans(data, k);
                
                return clusters;
            }

            kMeans(data, k, maxIterations = 50) {
                const n = data.length;
                const dim = data[0].length;

                // Initialize centroids randomly
                let centroids = [];
                for (let i = 0; i < k; i++) {
                    centroids.push(data[Math.floor(Math.random() * n)].slice());
                }

                let assignments = new Array(n).fill(0);

                for (let iter = 0; iter < maxIterations; iter++) {
                    // Assign points to nearest centroid
                    for (let i = 0; i < n; i++) {
                        let minDist = Infinity;
                        let minIdx = 0;

                        for (let j = 0; j < k; j++) {
                            const dist = this.euclideanDistance(data[i], centroids[j]);
                            if (dist < minDist) {
                                minDist = dist;
                                minIdx = j;
                            }
                        }

                        assignments[i] = minIdx;
                    }

                    // Update centroids
                    const newCentroids = Array(k).fill(0).map(() => Array(dim).fill(0));
                    const counts = Array(k).fill(0);

                    for (let i = 0; i < n; i++) {
                        const cluster = assignments[i];
                        counts[cluster]++;
                        for (let d = 0; d < dim; d++) {
                            newCentroids[cluster][d] += data[i][d];
                        }
                    }

                    for (let j = 0; j < k; j++) {
                        if (counts[j] > 0) {
                            for (let d = 0; d < dim; d++) {
                                newCentroids[j][d] /= counts[j];
                            }
                        }
                    }

                    centroids = newCentroids;
                }

                return { assignments, centroids };
            }

            euclideanDistance(a, b) {
                return Math.sqrt(a.reduce((sum, val, i) => sum + Math.pow(val - b[i], 2), 0));
            }

            // Predict churn and calculate CLV
            predictChurn(persona, purchaseProb) {
                // Factors affecting repurchase
                let repurchaseRate = purchaseProb / 100;

                // High brand loyalty increases retention
                repurchaseRate += (persona.brandLoyalty - 5) * 0.03;

                // Health-conscious customers are more likely to stick with protein drinks
                repurchaseRate += (persona.healthConsciousness - 5) * 0.02;

                // Price-sensitive customers churn more
                repurchaseRate -= (persona.priceSensitivity - 5) * 0.025;

                // Age factor: mature customers are more loyal
                if (persona.age > 35 && persona.age < 55) {
                    repurchaseRate += 0.08;
                }

                // Urban customers have more alternatives (higher churn)
                if (persona.cityType === 'Urban') {
                    repurchaseRate -= 0.05;
                }

                repurchaseRate = Math.max(0.1, Math.min(0.95, repurchaseRate));

                // Calculate CLV
                // Monthly purchases * repurchase rate * average lifetime (months) * margin
                const monthlyPurchases = repurchaseRate;
                const avgLifetimeMonths = 12 / (1 - repurchaseRate); // Geometric series
                const margin = 0.4; // 40% margin
                const clv = monthlyPurchases * avgLifetimeMonths * state.price * margin;

                return {
                    repurchaseRate: repurchaseRate * 100,
                    churnRisk: (1 - repurchaseRate) * 100,
                    clv: Math.round(clv)
                };
            }

            // Estimate Total Addressable Market using regression
            estimateTAM(config) {
                // Base market size for women's protein drinks in India
                const urbanPopulation = 377000000; // 2026 estimate
                const tier2Population = 255000000;
                
                // Target demographic: Women 18-65
                const targetRatio = 0.35; // 35% of population
                
                // Addressable percentage based on product positioning
                let addressableRate = 0.02; // Base 2%

                // Premium products address smaller market
                if (config.packaging === 'premium') {
                    addressableRate *= 0.6;
                }

                // Sugar-free expands health-conscious market
                if (config.sugarFree) {
                    addressableRate *= 1.4;
                }

                // Influencer marketing increases awareness
                if (config.influencer) {
                    addressableRate *= 1.3;
                }

                // Price affects market size
                if (config.price < 400) {
                    addressableRate *= 1.5;
                } else if (config.price > 500) {
                    addressableRate *= 0.7;
                }

                const tam = Math.round(
                    (urbanPopulation + tier2Population) * targetRatio * addressableRate
                );

                return {
                    total: tam,
                    urban: Math.round(urbanPopulation * targetRatio * addressableRate),
                    tier2: Math.round(tier2Population * targetRatio * addressableRate)
                };
            }

            // Find optimal price point
            findOptimalPrice(personas, config) {
                let bestPrice = 299;
                let bestRevenue = 0;
                let bestConfig = null;

                // Test different price points
                for (let price = 299; price <= 599; price += 25) {
                    const testConfig = { ...config, price };
                    let totalRevenue = 0;

                    personas.forEach(persona => {
                        const prob = this.predictPurchase(persona, testConfig) / 100;
                        const revenue = prob * price * (persona.weight / 100);
                        totalRevenue += revenue;
                    });

                    if (totalRevenue > bestRevenue) {
                        bestRevenue = totalRevenue;
                        bestPrice = price;
                        bestConfig = testConfig;
                    }
                }

                return {
                    optimalPrice: bestPrice,
                    expectedRevenue: bestRevenue * 100, // Scale up
                    configuration: bestConfig
                };
            }
        }

        // ========================================
        // STATE & INITIALIZATION
        // ========================================

        let state = {
            price: 449,
            sugarFree: true,
            packaging: 'basic',
            influencer: true
        };

        let mlEngine = new MLEngine();
        let personas = [];
        let charts = {};

        // Base persona templates
        const basePersonas = [
            {
                name: "Urban Health Enthusiast",
                cityType: "Urban",
                incomeLevel: "High",
                healthConsciousness: 9,
                priceSensitivity: 3,
                brandLoyalty: 7,
                weight: 15
            },
            {
                name: "Working Professional",
                cityType: "Urban",
                incomeLevel: "Medium",
                healthConsciousness: 7,
                priceSensitivity: 6,
                brandLoyalty: 5,
                weight: 20
            },
            {
                name: "Budget-Conscious Mother",
                cityType: "Tier-2",
                incomeLevel: "Medium",
                healthConsciousness: 6,
                priceSensitivity: 8,
                brandLoyalty: 4,
                weight: 18
            },
            {
                name: "Fitness-Focused Millennial",
                cityType: "Urban",
                incomeLevel: "High",
                healthConsciousness: 10,
                priceSensitivity: 2,
                brandLoyalty: 6,
                weight: 12
            },
            {
                name: "Traditional Homemaker",
                cityType: "Tier-2",
                incomeLevel: "Low",
                healthConsciousness: 5,
                priceSensitivity: 9,
                brandLoyalty: 8,
                weight: 15
            },
            {
                name: "Young Student",
                cityType: "Urban",
                incomeLevel: "Low",
                healthConsciousness: 4,
                priceSensitivity: 10,
                brandLoyalty: 3,
                weight: 10
            },
            {
                name: "Senior Citizen",
                cityType: "Tier-2",
                incomeLevel: "Medium",
                healthConsciousness: 8,
                priceSensitivity: 7,
                brandLoyalty: 9,
                weight: 6
            },
            {
                name: "Corporate Executive",
                cityType: "Urban",
                incomeLevel: "High",
                healthConsciousness: 7,
                priceSensitivity: 4,
                brandLoyalty: 6,
                weight: 4
            }
        ];

        // Generate personas
        function generatePersonas() {
            const generated = [];
            const personasPerTemplate = Math.floor(500 / basePersonas.length);
            
            basePersonas.forEach((template, index) => {
                const count = index === basePersonas.length - 1 
                    ? 500 - generated.length
                    : personasPerTemplate;
                
                for (let i = 0; i < count; i++) {
                    generated.push({
                        ...template,
                        id: generated.length + 1,
                        age: 18 + Math.floor(Math.random() * 47),
                        healthConsciousness: Math.max(1, Math.min(10, template.healthConsciousness + (Math.random() - 0.5) * 2)),
                        priceSensitivity: Math.max(1, Math.min(10, template.priceSensitivity + (Math.random() - 0.5) * 2)),
                        brandLoyalty: Math.max(1, Math.min(10, template.brandLoyalty + (Math.random() - 0.5) * 2))
                    });
                }
            });
            
            return generated;
        }

        // Rule-based probability (original formula)
        function calculateRuleBasedProbability(persona, config) {
            let probability = 50;

            const priceScore = (1 - ((config.price - 299) / 300)) * 10;
            const priceImpact = (10 - persona.priceSensitivity) * priceScore * 0.3;
            probability += priceImpact;

            if (config.sugarFree) {
                probability += persona.healthConsciousness * 1.5;
            } else {
                probability += persona.healthConsciousness * -0.8;
            }

            if (config.packaging === 'premium') {
                probability += persona.brandLoyalty * 0.8;
                if (persona.incomeLevel === 'High') {
                    probability += 5;
                }
            }

            if (config.influencer) {
                probability += (11 - persona.brandLoyalty) * 0.7;
                if (persona.cityType === 'Urban' && persona.age < 35) {
                    probability += 8;
                }
            }

            if (persona.incomeLevel === 'Low' && config.price > 399) {
                probability -= 15;
            } else if (persona.incomeLevel === 'High') {
                probability += 5;
            }

            return Math.max(0, Math.min(100, probability));
        }

        // Initialize ML models
        async function initializeML() {
            document.getElementById('mlStatus').innerHTML = 'üîÑ Training ML models (this may take 10-20 seconds)...';
            
            personas = generatePersonas();
            await mlEngine.trainPurchaseModel();
            
            document.getElementById('mlStatus').innerHTML = '‚úÖ ML models ready! Neural network trained on 2000 FMCG scenarios.';
            document.getElementById('runSimulation').disabled = false;
        }

        // Run complete simulation
        async function runSimulation() {
            document.getElementById('placeholder').classList.add('hidden');
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('results').classList.add('hidden');

            // Small delay to show loading
            await new Promise(resolve => setTimeout(resolve, 500));

            // Calculate rule-based probabilities
            const ruleResults = personas.map(p => ({
                persona: p,
                probability: calculateRuleBasedProbability(p, state)
            }));

            const ruleAvgProb = ruleResults.reduce((sum, r) => sum + r.probability, 0) / personas.length;

            // Calculate ML probabilities
            const mlResults = personas.map(p => ({
                persona: p,
                probability: mlEngine.predictPurchase(p, state)
            }));

            const mlAvgProb = mlResults.reduce((sum, r) => sum + r.probability, 0) / personas.length;

            // Calculate revenue
            const revenue = mlResults.reduce((sum, r) => {
                return sum + (r.probability / 100) * state.price * 100 * (r.persona.weight / 100);
            }, 0);

            // Churn prediction and CLV
            const churnData = mlResults.map(r => ({
                ...r,
                ...mlEngine.predictChurn(r.persona, r.probability)
            }));

            const avgCLV = churnData.reduce((sum, d) => sum + d.clv, 0) / churnData.length;

            // Segment-wise churn analysis
            const segmentChurn = analyzeSegmentChurn(churnData);

            // Market size estimation
            const tamData = mlEngine.estimateTAM(state);

            // Optimal price recommendation
            const optimalPricing = mlEngine.findOptimalPrice(personas, state);

            // Clustering
            const clusterResult = mlEngine.performClustering(personas, 6);

            // Update UI
            updateDashboard({
                ruleProb: ruleAvgProb,
                mlProb: mlAvgProb,
                revenue,
                avgCLV,
                tamData,
                optimalPricing,
                clusterResult,
                segmentChurn,
                ruleResults,
                mlResults
            });

            document.getElementById('loading').classList.add('hidden');
            document.getElementById('results').classList.remove('hidden');
        }

        function analyzeSegmentChurn(churnData) {
            const segments = {};
            
            basePersonas.forEach(bp => {
                segments[bp.name] = {
                    repurchase: [],
                    churn: [],
                    clv: []
                };
            });

            churnData.forEach(d => {
                if (segments[d.persona.name]) {
                    segments[d.persona.name].repurchase.push(d.repurchaseRate);
                    segments[d.persona.name].churn.push(d.churnRisk);
                    segments[d.persona.name].clv.push(d.clv);
                }
            });

            return Object.keys(segments).map(name => ({
                name,
                avgRepurchase: segments[name].repurchase.reduce((a,b)=>a+b,0) / segments[name].repurchase.length,
                avgChurn: segments[name].churn.reduce((a,b)=>a+b,0) / segments[name].churn.length,
                avgCLV: segments[name].clv.reduce((a,b)=>a+b,0) / segments[name].clv.length
            })).sort((a, b) => b.avgCLV - a.avgCLV);
        }

        function updateDashboard(data) {
            // Update metrics
            document.getElementById('ruleProb').textContent = data.ruleProb.toFixed(1);
            document.getElementById('mlProb').textContent = data.mlProb.toFixed(1);
            document.getElementById('revenue').textContent = (data.revenue / 1000).toFixed(0) + 'K';
            document.getElementById('clv').textContent = Math.round(data.avgCLV);
            document.getElementById('tam').textContent = (data.tamData.total / 1000000).toFixed(1) + 'M';

            // Optimal pricing
            document.getElementById('optimalPrice').textContent = 
                `‚Çπ${data.optimalPricing.optimalPrice} (${data.optimalPricing.optimalPrice > state.price ? '‚Üë' : '‚Üì'} ${Math.abs(data.optimalPricing.optimalPrice - state.price)})`;
            document.getElementById('optimalRevenue').textContent = 
                `‚Çπ${(data.optimalPricing.expectedRevenue / 1000).toFixed(0)}K/month (${((data.optimalPricing.expectedRevenue / data.revenue - 1) * 100).toFixed(1)}% increase)`;
            
            const confidence = Math.max(75, Math.min(95, 85 + (Math.random() - 0.5) * 10));
            document.getElementById('confidence').textContent = `${confidence.toFixed(1)}% (Based on 2000 training samples)`;

            // Risk assessment
            let riskLevel = 'Low';
            let riskClass = 'risk-low';
            if (data.mlProb < 40) {
                riskLevel = 'High';
                riskClass = 'risk-high';
            } else if (data.mlProb < 60) {
                riskLevel = 'Medium';
                riskClass = 'risk-medium';
            }
            document.getElementById('riskBadge').textContent = riskLevel;
            document.getElementById('riskBadge').className = 'risk-badge ' + riskClass;

            // Most responsive segment
            const sortedSegments = basePersonas.map(bp => {
                const segmentPersonas = personas.filter(p => p.name === bp.name);
                const avgProb = segmentPersonas.reduce((sum, p) => {
                    return sum + mlEngine.predictPurchase(p, state);
                }, 0) / segmentPersonas.length;
                return { name: bp.name, prob: avgProb };
            }).sort((a, b) => b.prob - a.prob);

            document.getElementById('responsiveSegment').textContent = 
                `${sortedSegments[0].name} (${sortedSegments[0].prob.toFixed(1)}% ML-predicted probability)`;

            // Recommendation
            let recommendation = '';
            if (state.price !== data.optimalPricing.optimalPrice) {
                recommendation = `ML recommends adjusting price to ‚Çπ${data.optimalPricing.optimalPrice} for ${((data.optimalPricing.expectedRevenue / data.revenue - 1) * 100).toFixed(1)}% revenue increase.`;
            } else {
                recommendation = 'Current pricing is optimal according to ML model. Focus on execution and distribution.';
            }
            document.getElementById('recommendation').textContent = recommendation;

            // Churn table
            const churnTableHTML = data.segmentChurn.map(s => {
                const priority = s.avgCLV > 1500 ? 'üî• High' : s.avgCLV > 800 ? '‚ö†Ô∏è Medium' : 'üìä Track';
                const churnColor = s.avgChurn > 40 ? '#f8d7da' : s.avgChurn > 25 ? '#fff3cd' : '#d4edda';
                return `
                    <tr style="background: ${churnColor}">
                        <td><strong>${s.name}</strong></td>
                        <td>${s.avgRepurchase.toFixed(1)}%</td>
                        <td>${s.avgChurn.toFixed(1)}%</td>
                        <td>‚Çπ${Math.round(s.avgCLV)}</td>
                        <td>${priority}</td>
                    </tr>
                `;
            }).join('');
            document.getElementById('churnTable').innerHTML = churnTableHTML;

            // Regional data
            document.getElementById('regionalData').innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <div style="background: white; padding: 15px; border-radius: 8px;">
                        <div style="font-weight: bold; color: #333; margin-bottom: 5px;">Total TAM</div>
                        <div style="font-size: 1.8em; color: #667eea;">${(data.tamData.total / 1000000).toFixed(1)}M customers</div>
                    </div>
                    <div style="background: white; padding: 15px; border-radius: 8px;">
                        <div style="font-weight: bold; color: #333; margin-bottom: 5px;">Market Value</div>
                        <div style="font-size: 1.8em; color: #667eea;">‚Çπ${((data.tamData.total * state.price * 0.02) / 1000000000).toFixed(1)}B</div>
                    </div>
                    <div style="background: white; padding: 15px; border-radius: 8px;">
                        <div style="font-weight: bold; color: #333; margin-bottom: 5px;">Urban Markets</div>
                        <div style="font-size: 1.5em; color: #667eea;">${(data.tamData.urban / 1000000).toFixed(1)}M</div>
                    </div>
                    <div style="background: white; padding: 15px; border-radius: 8px;">
                        <div style="font-weight: bold; color: #333; margin-bottom: 5px;">Tier-2 Markets</div>
                        <div style="font-size: 1.5em; color: #667eea;">${(data.tamData.tier2 / 1000000).toFixed(1)}M</div>
                    </div>
                </div>
            `;

            // Charts
            updateClusterChart(data.clusterResult);
            updateComparisonChart(data.ruleResults, data.mlResults);
            updateRevenueChart();

            document.getElementById('clusterCount').textContent = data.clusterResult.centroids.length;
        }

        function updateClusterChart(clusterResult) {
            const ctx = document.getElementById('clusterChart').getContext('2d');
            
            if (charts.cluster) charts.cluster.destroy();

            // Count personas per cluster
            const clusterCounts = {};
            clusterResult.assignments.forEach(c => {
                clusterCounts[c] = (clusterCounts[c] || 0) + 1;
            });

            const labels = Object.keys(clusterCounts).map(c => `Cluster ${parseInt(c)+1}`);
            const data = Object.values(clusterCounts);

            charts.cluster = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Number of Customers',
                        data,
                        backgroundColor: ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#43e97b', '#fa709a'],
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } }
                }
            });
        }

        function updateComparisonChart(ruleResults, mlResults) {
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            
            if (charts.comparison) charts.comparison.destroy();

            // Aggregate by segment
            const segments = {};
            basePersonas.forEach(bp => {
                segments[bp.name] = { rule: 0, ml: 0, count: 0 };
            });

            ruleResults.forEach((r, i) => {
                if (segments[r.persona.name]) {
                    segments[r.persona.name].rule += r.probability;
                    segments[r.persona.name].ml += mlResults[i].probability;
                    segments[r.persona.name].count++;
                }
            });

            const labels = Object.keys(segments);
            const ruleData = labels.map(l => segments[l].rule / segments[l].count);
            const mlData = labels.map(l => segments[l].ml / segments[l].count);

            charts.comparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Rule-Based',
                            data: ruleData,
                            backgroundColor: '#999',
                            borderRadius: 6
                        },
                        {
                            label: 'ML Model',
                            data: mlData,
                            backgroundColor: '#43e97b',
                            borderRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { callback: v => v + '%' }
                        }
                    }
                }
            });
        }

        function updateRevenueChart() {
            const ctx = document.getElementById('revenueChart').getContext('2d');
            
            if (charts.revenue) charts.revenue.destroy();

            const pricePoints = [];
            const revenues = [];

            for (let price = 299; price <= 599; price += 25) {
                const testConfig = { ...state, price };
                let totalRevenue = 0;

                personas.forEach(p => {
                    const prob = mlEngine.predictPurchase(p, testConfig) / 100;
                    totalRevenue += prob * price * 100 * (p.weight / 100);
                });

                pricePoints.push('‚Çπ' + price);
                revenues.push(totalRevenue / 1000);
            }

            charts.revenue = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: pricePoints,
                    datasets: [{
                        label: 'Expected Revenue (‚ÇπK)',
                        data: revenues,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } }
                }
            });
        }

        // Event listeners
        document.getElementById('priceSlider').addEventListener('input', (e) => {
            state.price = parseInt(e.target.value);
            document.getElementById('priceValue').textContent = state.price;
        });

        document.getElementById('sugarYesBtn').addEventListener('click', () => {
            state.sugarFree = true;
            document.getElementById('sugarYesBtn').classList.add('active');
            document.getElementById('sugarNoBtn').classList.remove('active');
        });

        document.getElementById('sugarNoBtn').addEventListener('click', () => {
            state.sugarFree = false;
            document.getElementById('sugarNoBtn').classList.add('active');
            document.getElementById('sugarYesBtn').classList.remove('active');
        });

        document.getElementById('packagingSelect').addEventListener('change', (e) => {
            state.packaging = e.target.value;
        });

        document.getElementById('influencerYesBtn').addEventListener('click', () => {
            state.influencer = true;
            document.getElementById('influencerYesBtn').classList.add('active');
            document.getElementById('influencerNoBtn').classList.remove('active');
        });

        document.getElementById('influencerNoBtn').addEventListener('click', () => {
            state.influencer = false;
            document.getElementById('influencerNoBtn').classList.add('active');
            document.getElementById('influencerYesBtn').classList.remove('active');
        });

        document.getElementById('runSimulation').addEventListener('click', runSimulation);

        // Initialize on load
        document.getElementById('runSimulation').disabled = true;
        window.addEventListener('load', initializeML);
    </script>
</body>
</html>
